{"version":3,"sources":["../node_modules/png-chunks-extract/index.js","../node_modules/crc-32/crc32.js","../node_modules/png-chunk-text/index.js","../node_modules/png-chunks-encode/index.js","../node_modules/png-chunk-text/encode.js","../node_modules/png-chunk-text/decode.js","../node_modules/sliced/index.js","ChalkBoard/data/image.js","ChalkBoardPlayer/data/image.js"],"names":["crc32","require","module","exports","data","Error","ended","chunks","idx","length","uint8","uint32","chunk","Uint8Array","name","String","fromCharCode","push","i","crcActual","int32","buf","chunkData","buffer","slice","Int32Array","Uint32Array","factory","CRC32","version","table","c","Array","n","signed_crc_table","use_buffer","Buffer","crc32_buf_8","crc","L","bstr","charCodeAt","str","d","DO_NOT_EXPORT_CRC","encode","decode","sliced","totalSize","output","size","nameChars","j","crcCheck","concat","keyword","content","test","code","naming","text","args","sliceEnd","ret","len","start","Math","max","undefined","blobToArrayBuffer","blob","arrayBuffer","Promise","resolve","reject","reader","FileReader","onload","event","target","result","readAsArrayBuffer","getTEXtChunk","a","decodePng","metadataChunk","find","tEXt","encodePngMetadata","metadata","MIME_TYPES","excalidraw","JSON","compress","stringify","splice","Blob","encodePng","type","png","decodePngMetadata","encodedData","parse","EXPORT_DATA_TYPES","console","error","encodeSvgMetadata","stringToBase64","base64","decodeSvgMetadata","svg","includes","match","versionMatch","isByteString","base64ToString","json"],"mappings":"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","file":"static/js/image.74dbab4f.chunk.js","sourcesContent":["var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n","/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\nvar CRC32;\n(function (factory) {\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t  factory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n}(function(CRC32) {\nCRC32.version = '0.3.0';\n/* see perf/crc32table.js */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar table = signed_crc_table();\n/* charCodeAt is the best approach for binary strings */\nvar use_buffer = typeof Buffer !== 'undefined';\nfunction crc32_bstr(bstr) {\n\tif(bstr.length > 32768) if(use_buffer) return crc32_buf_8(new Buffer(bstr));\n\tvar crc = -1, L = bstr.length - 1;\n\tfor(var i = 0; i < L;) {\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t}\n\tif(i === L) crc = (crc >>> 8) ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf(buf) {\n\tif(buf.length > 10000) return crc32_buf_8(buf);\n\tfor(var crc = -1, i = 0, L=buf.length-3; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+3) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf_8(buf) {\n\tfor(var crc = -1, i = 0, L=buf.length-7; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+7) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\n/* much much faster to intertwine utf8 and crc */\nfunction crc32_str(str) {\n\tfor(var crc = -1, i = 0, L=str.length, c, d; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ c) & 0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (192|((c>>6)&31))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++) & 1023;\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (240|((c>>8)&7))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>2)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((d>>6)&15)|(c&3))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(d&63))) & 0xFF];\n\t\t} else {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (224|((c>>12)&15))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>6)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t}\n\t}\n\treturn crc ^ -1;\n}\nCRC32.table = table;\nCRC32.bstr = crc32_bstr;\nCRC32.buf = crc32_buf;\nCRC32.str = crc32_str;\n}));\n","exports.encode = require('./encode')\nexports.decode = require('./decode')\n","var sliced = require('sliced')\nvar crc32 = require('crc-32')\n\nmodule.exports = encodeChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction encodeChunks (chunks) {\n  var totalSize = 8\n  var idx = totalSize\n  var i\n\n  for (i = 0; i < chunks.length; i++) {\n    totalSize += chunks[i].data.length\n    totalSize += 12\n  }\n\n  var output = new Uint8Array(totalSize)\n\n  output[0] = 0x89\n  output[1] = 0x50\n  output[2] = 0x4E\n  output[3] = 0x47\n  output[4] = 0x0D\n  output[5] = 0x0A\n  output[6] = 0x1A\n  output[7] = 0x0A\n\n  for (i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i]\n    var name = chunk.name\n    var data = chunk.data\n    var size = data.length\n    var nameChars = [\n      name.charCodeAt(0),\n      name.charCodeAt(1),\n      name.charCodeAt(2),\n      name.charCodeAt(3)\n    ]\n\n    uint32[0] = size\n    output[idx++] = uint8[3]\n    output[idx++] = uint8[2]\n    output[idx++] = uint8[1]\n    output[idx++] = uint8[0]\n\n    output[idx++] = nameChars[0]\n    output[idx++] = nameChars[1]\n    output[idx++] = nameChars[2]\n    output[idx++] = nameChars[3]\n\n    for (var j = 0; j < size;) {\n      output[idx++] = data[j++]\n    }\n\n    var crcCheck = nameChars.concat(sliced(data))\n    var crc = crc32.buf(crcCheck)\n\n    int32[0] = crc\n    output[idx++] = uint8[3]\n    output[idx++] = uint8[2]\n    output[idx++] = uint8[1]\n    output[idx++] = uint8[0]\n  }\n\n  return output\n}\n","module.exports = encode\n\nfunction encode (keyword, content) {\n  keyword = String(keyword)\n  content = String(content)\n\n  if (!/^[\\x00-\\xFF]+$/.test(keyword) || !/^[\\x00-\\xFF]+$/.test(content)) {\n    throw new Error('Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression')\n  }\n\n  if (keyword.length >= 80) {\n    throw new Error('Keyword \"' + keyword + '\" is longer than the 79-character limit imposed by the PNG specification')\n  }\n\n  var totalSize = keyword.length + content.length + 1\n  var output = new Uint8Array(totalSize)\n  var idx = 0\n  var code\n\n  for (var i = 0; i < keyword.length; i++) {\n    if (!(code = keyword.charCodeAt(i))) {\n      throw new Error('0x00 character is not permitted in tEXt keywords')\n    }\n\n    output[idx++] = code\n  }\n\n  output[idx++] = 0\n\n  for (var j = 0; j < content.length; j++) {\n    if (!(code = content.charCodeAt(j))) {\n      throw new Error('0x00 character is not permitted in tEXt content')\n    }\n\n    output[idx++] = code\n  }\n\n  return {\n    name: 'tEXt',\n    data: output\n  }\n}\n","module.exports = decode\n\nfunction decode (data) {\n  if (data.data && data.name) {\n    data = data.data\n  }\n\n  var naming = true\n  var text = ''\n  var name = ''\n\n  for (var i = 0; i < data.length; i++) {\n    var code = data[i]\n\n    if (naming) {\n      if (code) {\n        name += String.fromCharCode(code)\n      } else {\n        naming = false\n      }\n    } else {\n      if (code) {\n        text += String.fromCharCode(code)\n      } else {\n        throw new Error('Invalid NULL character found. 0x00 character is not permitted in tEXt content')\n      }\n    }\n  }\n\n  return {\n    keyword: name,\n    text: text\n  }\n}\n","\n/**\n * An Array.prototype.slice.call(arguments) alternative\n *\n * @param {Object} args something with a length\n * @param {Number} slice\n * @param {Number} sliceEnd\n * @api public\n */\n\nmodule.exports = function (args, slice, sliceEnd) {\n  var ret = [];\n  var len = args.length;\n\n  if (0 === len) return ret;\n\n  var start = slice < 0\n    ? Math.max(0, slice + len)\n    : slice || 0;\n\n  if (sliceEnd !== undefined) {\n    len = sliceEnd < 0\n      ? sliceEnd + len\n      : sliceEnd\n  }\n\n  while (len-- > start) {\n    ret[len - start] = args[len];\n  }\n\n  return ret;\n}\n\n","import decodePng from \"png-chunks-extract\";\r\nimport tEXt from \"png-chunk-text\";\r\nimport encodePng from \"png-chunks-encode\";\r\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\r\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"../constants\";\r\n// -----------------------------------------------------------------------------\r\n// PNG\r\n// -----------------------------------------------------------------------------\r\nconst blobToArrayBuffer = (blob) => {\r\n    if (\"arrayBuffer\" in blob) {\r\n        return blob.arrayBuffer();\r\n    }\r\n    // Safari\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = (event) => {\r\n            if (!event.target?.result) {\r\n                return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\r\n            }\r\n            resolve(event.target.result);\r\n        };\r\n        reader.readAsArrayBuffer(blob);\r\n    });\r\n};\r\nexport const getTEXtChunk = async (blob) => {\r\n    const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\r\n    const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\r\n    if (metadataChunk) {\r\n        return tEXt.decode(metadataChunk.data);\r\n    }\r\n    return null;\r\n};\r\nexport const encodePngMetadata = async ({ blob, metadata, }) => {\r\n    const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\r\n    const metadataChunk = tEXt.encode(MIME_TYPES.excalidraw, JSON.stringify(await encode({\r\n        text: metadata,\r\n        compress: true,\r\n    })));\r\n    // insert metadata before last chunk (iEND)\r\n    chunks.splice(-1, 0, metadataChunk);\r\n    return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });\r\n};\r\nexport const decodePngMetadata = async (blob) => {\r\n    const metadata = await getTEXtChunk(blob);\r\n    if (metadata?.keyword === MIME_TYPES.excalidraw) {\r\n        try {\r\n            const encodedData = JSON.parse(metadata.text);\r\n            if (!(\"encoded\" in encodedData)) {\r\n                // legacy, un-encoded scene JSON\r\n                if (\"type\" in encodedData &&\r\n                    encodedData.type === EXPORT_DATA_TYPES.excalidraw) {\r\n                    return metadata.text;\r\n                }\r\n                throw new Error(\"FAILED\");\r\n            }\r\n            return await decode(encodedData);\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n            throw new Error(\"FAILED\");\r\n        }\r\n    }\r\n    throw new Error(\"INVALID\");\r\n};\r\n// -----------------------------------------------------------------------------\r\n// SVG\r\n// -----------------------------------------------------------------------------\r\nexport const encodeSvgMetadata = async ({ text }) => {\r\n    const base64 = await stringToBase64(JSON.stringify(await encode({ text })), true /* is already byte string */);\r\n    let metadata = \"\";\r\n    metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\r\n    metadata += `<!-- payload-version:2 -->`;\r\n    metadata += \"<!-- payload-start -->\";\r\n    metadata += base64;\r\n    metadata += \"<!-- payload-end -->\";\r\n    return metadata;\r\n};\r\nexport const decodeSvgMetadata = async ({ svg }) => {\r\n    if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\r\n        const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\r\n        if (!match) {\r\n            throw new Error(\"INVALID\");\r\n        }\r\n        const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\r\n        const version = versionMatch?.[1] || \"1\";\r\n        const isByteString = version !== \"1\";\r\n        try {\r\n            const json = await base64ToString(match[1], isByteString);\r\n            const encodedData = JSON.parse(json);\r\n            if (!(\"encoded\" in encodedData)) {\r\n                // legacy, un-encoded scene JSON\r\n                if (\"type\" in encodedData &&\r\n                    encodedData.type === EXPORT_DATA_TYPES.excalidraw) {\r\n                    return json;\r\n                }\r\n                throw new Error(\"FAILED\");\r\n            }\r\n            return await decode(encodedData);\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n            throw new Error(\"FAILED\");\r\n        }\r\n    }\r\n    throw new Error(\"INVALID\");\r\n};\r\n","import decodePng from \"png-chunks-extract\";\r\nimport tEXt from \"png-chunk-text\";\r\nimport encodePng from \"png-chunks-encode\";\r\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\r\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"../constants\";\r\n// -----------------------------------------------------------------------------\r\n// PNG\r\n// -----------------------------------------------------------------------------\r\nconst blobToArrayBuffer = (blob) => {\r\n    if (\"arrayBuffer\" in blob) {\r\n        return blob.arrayBuffer();\r\n    }\r\n    // Safari\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = (event) => {\r\n            if (!event.target?.result) {\r\n                return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\r\n            }\r\n            resolve(event.target.result);\r\n        };\r\n        reader.readAsArrayBuffer(blob);\r\n    });\r\n};\r\nexport const getTEXtChunk = async (blob) => {\r\n    const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\r\n    const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\r\n    if (metadataChunk) {\r\n        return tEXt.decode(metadataChunk.data);\r\n    }\r\n    return null;\r\n};\r\nexport const encodePngMetadata = async ({ blob, metadata, }) => {\r\n    const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\r\n    const metadataChunk = tEXt.encode(MIME_TYPES.excalidraw, JSON.stringify(await encode({\r\n        text: metadata,\r\n        compress: true,\r\n    })));\r\n    // insert metadata before last chunk (iEND)\r\n    chunks.splice(-1, 0, metadataChunk);\r\n    return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });\r\n};\r\nexport const decodePngMetadata = async (blob) => {\r\n    const metadata = await getTEXtChunk(blob);\r\n    if (metadata?.keyword === MIME_TYPES.excalidraw) {\r\n        try {\r\n            const encodedData = JSON.parse(metadata.text);\r\n            if (!(\"encoded\" in encodedData)) {\r\n                // legacy, un-encoded scene JSON\r\n                if (\"type\" in encodedData &&\r\n                    encodedData.type === EXPORT_DATA_TYPES.excalidraw) {\r\n                    return metadata.text;\r\n                }\r\n                throw new Error(\"FAILED\");\r\n            }\r\n            return await decode(encodedData);\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n            throw new Error(\"FAILED\");\r\n        }\r\n    }\r\n    throw new Error(\"INVALID\");\r\n};\r\n// -----------------------------------------------------------------------------\r\n// SVG\r\n// -----------------------------------------------------------------------------\r\nexport const encodeSvgMetadata = async ({ text }) => {\r\n    const base64 = await stringToBase64(JSON.stringify(await encode({ text })), true /* is already byte string */);\r\n    let metadata = \"\";\r\n    metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\r\n    metadata += `<!-- payload-version:2 -->`;\r\n    metadata += \"<!-- payload-start -->\";\r\n    metadata += base64;\r\n    metadata += \"<!-- payload-end -->\";\r\n    return metadata;\r\n};\r\nexport const decodeSvgMetadata = async ({ svg }) => {\r\n    if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\r\n        const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\r\n        if (!match) {\r\n            throw new Error(\"INVALID\");\r\n        }\r\n        const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\r\n        const version = versionMatch?.[1] || \"1\";\r\n        const isByteString = version !== \"1\";\r\n        try {\r\n            const json = await base64ToString(match[1], isByteString);\r\n            const encodedData = JSON.parse(json);\r\n            if (!(\"encoded\" in encodedData)) {\r\n                // legacy, un-encoded scene JSON\r\n                if (\"type\" in encodedData &&\r\n                    encodedData.type === EXPORT_DATA_TYPES.excalidraw) {\r\n                    return json;\r\n                }\r\n                throw new Error(\"FAILED\");\r\n            }\r\n            return await decode(encodedData);\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n            throw new Error(\"FAILED\");\r\n        }\r\n    }\r\n    throw new Error(\"INVALID\");\r\n};\r\n"],"sourceRoot":""}